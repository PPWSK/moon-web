<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MOON Lamp — Firmware Update</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: #ffffff; color: #030303;
  padding: 2rem 1rem; max-width: 520px; margin: 0 auto;
  line-height: 1.6;
}
h1 { font-size: 1.5rem; font-weight: 400; margin-bottom: 0.25rem; color: #030303; letter-spacing: 0.02em; }
.subtitle { font-size: 0.8rem; color: #9D9D9D; margin-bottom: 2rem; letter-spacing: 0.01em; }
.card {
  border-top: 1px solid #e0e0e0; padding: 1.25rem 0; margin-bottom: 0;
}
.card:last-child { border-bottom: 1px solid #e0e0e0; }
.card h2 {
  font-size: 0.7rem; color: #9D9D9D; margin-bottom: 0.75rem;
  text-transform: uppercase; letter-spacing: 0.1em; font-weight: 400;
}
button {
  width: 100%; padding: 12px 2rem; border: 1px solid #030303;
  background: transparent; color: #030303;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 0.875rem; font-weight: 400; cursor: pointer; margin-bottom: 8px;
  transition: border-color 0.2s, color 0.2s;
  letter-spacing: 0.01em;
}
button:disabled { opacity: 0.3; cursor: not-allowed; }
button:not(:disabled):hover { border-color: #004AFF; color: #004AFF; }
.btn-blue { border-color: #030303; color: #030303; }
.btn-green { border-color: #030303; color: #030303; }
.btn-green:not(:disabled):hover { border-color: #004AFF; color: #004AFF; }
.btn-red { border-color: #8a1b1b; color: #8a1b1b; }
.btn-red:not(:disabled):hover { border-color: #030303; color: #030303; }
.btn-orange { border-color: #030303; color: #030303; background: #030303; color: #ffffff; }
.btn-orange:not(:disabled):hover { background: #004AFF; border-color: #004AFF; color: #ffffff; }
.status { font-size: 0.8rem; color: #9D9D9D; margin-top: 6px; word-break: break-all; }

.progress-bar {
  width: 100%; height: 3px; background: #e0e0e0;
  overflow: hidden; margin: 12px 0;
}
.progress-fill {
  height: 100%; background: #004AFF;
  transition: width 0.3s; display: flex; align-items: center;
  justify-content: center; font-size: 0; min-width: 0;
}
.progress-text { font-size: 0.8rem; color: #9D9D9D; margin-bottom: 8px; }

.log {
  background: #F8F8F8; padding: 12px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  font-size: 0.65rem; max-height: 200px; overflow-y: auto;
  color: #555; margin-top: 8px; white-space: pre-wrap;
  border: 1px solid #e0e0e0;
}
.stats { display: grid; grid-template-columns: 1fr 1fr; gap: 1px; margin-top: 12px; background: #e0e0e0; }
.stat { background: #ffffff; padding: 10px; text-align: center; }
.stat .val { font-size: 1.25rem; font-weight: 400; color: #030303; }
.stat .lbl { font-size: 0.65rem; color: #9D9D9D; text-transform: uppercase; letter-spacing: 0.08em; }
.slider-row { display: flex; align-items: center; gap: 10px; margin: 8px 0; }
.slider-row input[type=range] { flex: 1; accent-color: #004AFF; }
.slider-row .slider-val { font-size: 1rem; font-weight: 400; color: #030303; min-width: 50px; text-align: center; }
.info { font-size: 0.75rem; color: #9D9D9D; margin: 4px 0; }
.phase-display { font-size: 1.5rem; font-weight: 400; text-align: center; padding: 12px; letter-spacing: 0.02em; }
.phase-probe { color: #9D9D9D; }
.phase-count { color: #004AFF; }
.phase-go { color: #030303; }
.stage-label {
  font-size: 0.65rem; font-weight: 400; text-transform: uppercase;
  letter-spacing: 0.1em; padding: 4px 10px;
  display: inline-block; margin-bottom: 6px; border: 1px solid;
}
.stage-1 { border-color: #9D9D9D; color: #9D9D9D; }
.stage-2 { border-color: #030303; color: #030303; }

/* Platform warning */
.platform-warning {
  border: 1px solid #e0e0e0; padding: 2rem 1.5rem; margin-bottom: 1.5rem; text-align: center;
}
.platform-warning h2 { color: #030303; font-size: 1rem; font-weight: 400; margin-bottom: 0.75rem; text-transform: none; letter-spacing: 0.02em; }
.platform-warning p { font-size: 0.85rem; color: #555; margin: 8px 0; line-height: 1.6; }
.platform-warning .detail { font-size: 0.75rem; color: #9D9D9D; margin-top: 1rem; line-height: 1.6; }
.platform-warning a { color: #004AFF; text-decoration: none; }
.platform-warning a:hover { text-decoration: underline; }

/* Instructions */
.instructions { font-size: 0.8rem; color: #555; }
.instructions ol { padding-left: 1.25rem; }
.instructions li { margin: 0.5rem 0; }
.instructions .note { font-size: 0.75rem; color: #9D9D9D; font-style: italic; margin-top: 0.75rem; }

/* Firmware status */
.fw-status { display: flex; align-items: center; gap: 8px; margin: 6px 0; font-size: 0.8rem; color: #555; }
.fw-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
.fw-dot.loading { background: #9D9D9D; }
.fw-dot.ready { background: #030303; }
.fw-dot.error { background: #cc0000; }

/* Collapsible */
.collapse-toggle {
  background: none; border: none; color: #9D9D9D; font-size: 0.75rem;
  font-family: Helvetica, Arial, sans-serif;
  cursor: pointer; padding: 4px 0; width: auto; margin: 0; font-weight: 400;
  text-align: left; letter-spacing: 0.01em;
}
.collapse-toggle:hover { color: #004AFF; }

/* Footer */
.footer {
  padding: 2rem 0 1rem; text-align: center;
  font-size: 0.7rem; color: #9D9D9D; letter-spacing: 0.01em;
}
.footer a { color: #9D9D9D; text-decoration: none; }
.footer a:hover { color: #004AFF; }
</style>
</head>
<body>

<h1>MOON Lamp &mdash; Firmware Update</h1>
<div class="subtitle">Wireless firmware update for your MOON lamp</div>

<!-- Platform warning (shown/hidden by JS) -->
<div id="platformWarning" class="platform-warning" style="display:none">
  <h2 id="warnTitle">Unsupported Platform</h2>
  <p id="warnBody"></p>
  <div class="detail" id="warnDetail"></div>
</div>

<!-- No Web Bluetooth warning -->
<div id="noBleWarning" class="platform-warning" style="display:none">
  <h2>Web Bluetooth Not Available</h2>
  <p>This browser doesn't support Web Bluetooth.</p>
  <div class="detail">Use <strong>Google Chrome</strong> or <strong>Microsoft Edge</strong> on Android, Windows, Linux, or ChromeOS.</div>
</div>

<!-- Main content (hidden on unsupported platforms) -->
<div id="mainContent">

<div class="card">
  <h2>How It Works</h2>
  <div class="instructions">
    <p style="margin-bottom:0.5rem">The update has two parts:</p>
    <ol>
      <li><strong>Turn on</strong> your MOON lamp and wait for it to boot (~5s)</li>
      <li>Tap <strong>Connect</strong> and select your MOON device</li>
      <li>Tap <strong>Start Update</strong> &mdash; part 1 runs automatically</li>
      <li>When part 1 finishes, tap <strong>Connect</strong> again to reconnect</li>
      <li>Tap <strong>Start Update Part 2</strong> to complete the update</li>
    </ol>
    <div class="note">Keep your phone/computer close to the lamp and don't switch apps during transfer.</div>
  </div>
</div>

<div class="card">
  <h2>Connect</h2>
  <button id="btnConnect" class="btn-blue" onclick="doConnect()">Connect to MOON device</button>
  <div id="connStatus" class="fw-status">
    <span class="fw-dot" id="connDot" style="background:#9D9D9D"></span>
    <span id="connText">Not connected</span>
  </div>
</div>

<div class="card">
  <h2>Transfer</h2>

  <!-- Rescue mode (v4.5.1 devices) -->
  <div id="rescueControls" style="display:none">
    <button class="collapse-toggle" onclick="toggleAdvanced()" id="advToggle">+ Advanced settings</button>
    <div id="advPanel" style="display:none">
      <div class="slider-row">
        <span style="font-size:12px;color:#888">Pacing:</span>
        <input type="range" id="paceSlider" min="5" max="25" value="9" oninput="updatePaceLabel()">
        <span id="paceLabel" class="slider-val">9ms</span>
      </div>
      <div class="info">Packet pacing delay. Lower = faster but riskier. Default 9ms.</div>
    </div>
    <div class="info" style="margin-top:8px">The update runs automatically and takes about 2 minutes.</div>
    <button id="btnRescue" class="btn-orange" onclick="fullRescue()" disabled>Start Update</button>
  </div>

  <!-- Safe mode (skeleton / part 2) -->
  <div id="safeControls" style="display:none">
    <div class="slider-row">
      <span style="font-size:12px;color:#888">Pacing:</span>
      <input type="range" id="safePaceSlider" min="5" max="25" value="9" oninput="updateSafePaceLabel()">
      <span id="safePaceLabel" class="slider-val">9ms</span>
    </div>
    <button id="btnSafe" class="btn-orange" onclick="safeUpdate()" disabled>Start Update Part 2</button>
  </div>

  <!-- Between-stages message -->
  <div id="stage2Prompt" style="display:none">
    <div style="border:1px solid #e0e0e0;padding:1rem;margin-bottom:12px">
      <div style="font-size:0.85rem;color:#030303;font-weight:400;margin-bottom:0.5rem">Part 1 complete</div>
      <div style="font-size:0.75rem;color:#555">Tap <strong>Connect</strong> above to reconnect to your MOON, then tap <strong>Start Update Part 2</strong> below.</div>
    </div>
  </div>

  <div id="stageLabel" style="display:none"></div>
  <div id="phaseDisplay" class="phase-display" style="display:none"></div>

  <button id="btnStop" class="btn-red" onclick="stopOTA()" disabled style="display:none">Stop</button>
  <div id="progressText" class="progress-text" style="display:none">0%</div>
  <div class="progress-bar"><div id="progressFill" class="progress-fill" style="width:0%"></div></div>
  <div class="stats">
    <div class="stat"><div id="statSpeed" class="val">-</div><div class="lbl">KB/s</div></div>
    <div class="stat"><div id="statEta" class="val">-</div><div class="lbl">ETA (s)</div></div>
    <div class="stat"><div id="statSent" class="val">0</div><div class="lbl">Packets</div></div>
    <div class="stat"><div id="statAcked" class="val">0</div><div class="lbl">ACKed</div></div>
  </div>
</div>

<div class="card">
  <h2>Log</h2>
  <div id="log" class="log"></div>
  <button style="width:auto;padding:4px 12px;font-size:0.65rem;margin-top:6px;border:1px solid #e0e0e0;background:transparent;color:#9D9D9D" onclick="copyLog()" id="btnCopyLog">Copy</button>
</div>

<div class="footer">
  <a href="https://www.adu-studios.com">A.D.U. Studios</a>
  <br>Compatible with Android (Chrome), Windows (Chrome/Edge), Linux (Chrome), ChromeOS
  <br>Questions? <a href="mailto:info@adu-studios.com">info@adu-studios.com</a>
</div>

</div><!-- /mainContent -->

<script>
// ============================================================
//  Platform detection
// ============================================================

function detectPlatform() {
  const ua = navigator.userAgent;
  const platform = navigator.platform || '';

  const isIOS = /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isMacOS = /Macintosh|MacIntel/.test(ua) && !isIOS;
  const hasWebBluetooth = !!navigator.bluetooth;

  if (isIOS) {
    showPlatformWarning(
      'Not Available on iOS',
      'This update tool requires Web Bluetooth, which is not available on iOS. No iOS browser (Safari, Chrome, or others) supports this feature.',
      'Please use an <strong>Android phone</strong>, a <strong>Windows PC</strong>, or a <strong>Linux PC</strong> with Chrome. If you need help, reach out to <a href="mailto:info@adu-studios.com">info@adu-studios.com</a>.'
    );
    return false;
  }

  // macOS warning disabled for testing — re-enable before public release
  // if (isMacOS) {
  //   showPlatformWarning(
  //     'Not Available on macOS',
  //     'This update requires a Bluetooth feature that macOS does not support. This is a platform limitation that affects all macOS software.',
  //     'Please use an <strong>Android phone</strong>, a <strong>Windows PC</strong>, or a <strong>Linux PC</strong> with Chrome. If you need help, reach out to <a href="mailto:info@adu-studios.com">info@adu-studios.com</a>.'
  //   );
  //   return false;
  // }

  if (!hasWebBluetooth) {
    document.getElementById('noBleWarning').style.display = '';
    document.getElementById('mainContent').style.display = 'none';
    return false;
  }

  return true;
}

function showPlatformWarning(title, body, detail) {
  document.getElementById('warnTitle').textContent = title;
  document.getElementById('warnBody').innerHTML = body;
  document.getElementById('warnDetail').innerHTML = detail;
  document.getElementById('platformWarning').style.display = '';
  document.getElementById('mainContent').style.display = 'none';
}

// ============================================================
//  Constants
// ============================================================

const NUS_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const NUS_RX      = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const NUS_TX      = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

const FW_SKELETON_URL = 'firmware/skeleton.bin';
const FW_FULL_URL     = 'firmware/moon_s18.bin';
const FW_FULL_VERSION = 'v4.8.0';

// ============================================================
//  State
// ============================================================

let device = null;
let server = null;
let rxChar = null;
let txChar = null;
let skeletonFw = null;
let fullFw = null;
let running = false;
let probing = false;
let ackedCount = 0;
let lastAckedN = -1;
let isSkeleton = false;

// ============================================================
//  Auto-fetch firmware
// ============================================================

async function fetchFirmwareBin(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  const buf = await resp.arrayBuffer();
  return new Uint8Array(buf);
}

async function loadBundledFirmware() {
  try {
    log('Downloading firmware...');
    const [skel, full] = await Promise.all([
      fetchFirmwareBin(FW_SKELETON_URL),
      fetchFirmwareBin(FW_FULL_URL),
    ]);
    skeletonFw = skel;
    fullFw = full;
    log(`Firmware ${FW_FULL_VERSION} ready.`);
  } catch (err) {
    log(`Firmware download failed: ${err.message}`);
  }
  checkReady();
}

// ============================================================
//  UI helpers
// ============================================================

function copyLog() {
  const text = document.getElementById('log').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btnCopyLog');
    btn.textContent = 'Copied';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
}

function toggleAdvanced() {
  const panel = document.getElementById('advPanel');
  const btn = document.getElementById('advToggle');
  if (panel.style.display === 'none') {
    panel.style.display = '';
    btn.textContent = '- Hide advanced settings';
  } else {
    panel.style.display = 'none';
    btn.textContent = '+ Advanced settings';
  }
}

function updatePaceLabel() {
  document.getElementById('paceLabel').textContent = document.getElementById('paceSlider').value + 'ms';
}
function updateSafePaceLabel() {
  document.getElementById('safePaceLabel').textContent = document.getElementById('safePaceSlider').value + 'ms';
}

function log(msg) {
  const el = document.getElementById('log');
  const ts = new Date().toLocaleTimeString();
  el.textContent += `[${ts}] ${msg}\n`;
  el.scrollTop = el.scrollHeight;
}

function updateUI(id, text) { document.getElementById(id).textContent = text; }

function setConnStatus(text, state) {
  document.getElementById('connText').textContent = text;
  const dot = document.getElementById('connDot');
  const colors = { connected: '#030303', disconnected: '#9D9D9D', error: '#cc0000', pending: '#004AFF' };
  dot.style.background = colors[state] || colors.disconnected;
}

function showPhase(text, cls) {
  const el = document.getElementById('phaseDisplay');
  el.style.display = '';
  el.className = 'phase-display ' + cls;
  el.textContent = text;
}

function hidePhase() { document.getElementById('phaseDisplay').style.display = 'none'; }

function showStage(num) {
  const el = document.getElementById('stageLabel');
  el.style.display = '';
  el.innerHTML = `<span class="stage-label stage-${num}">Stage ${num} of 2</span>`;
}

function hideStage() { document.getElementById('stageLabel').style.display = 'none'; }

function resetProgress() {
  document.getElementById('progressFill').style.width = '0%';
  document.getElementById('progressText').textContent = '0%';
  document.getElementById('progressText').style.display = 'none';
  updateUI('statSent', '0');
  updateUI('statAcked', '0');
  updateUI('statSpeed', '-');
  updateUI('statEta', '-');
}

function showMode() {
  document.getElementById('rescueControls').style.display = isSkeleton ? 'none' : '';
  document.getElementById('safeControls').style.display = isSkeleton ? '' : 'none';
}

function checkReady() {
  if (isSkeleton) {
    document.getElementById('btnSafe').disabled = !(rxChar && fullFw);
  } else {
    document.getElementById('btnRescue').disabled = !(rxChar && skeletonFw && fullFw);
  }
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
//  BLE connection
// ============================================================

async function doConnect() {
  try {
    document.getElementById('stage2Prompt').style.display = 'none';
    log('Requesting BLE device...');
    device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'MOON' }],
      optionalServices: [NUS_SERVICE]
    });
    log(`Selected: ${device.name}`);
    setConnStatus(`Connecting to ${device.name}...`, 'pending');

    isSkeleton = device.name && device.name.toUpperCase().includes('SKEL');

    device.addEventListener('gattserverdisconnected', () => {
      if (!probing) {
        log('Disconnected.');
        setConnStatus('Disconnected', 'disconnected');
      }
      running = false;
    });

    server = await device.gatt.connect();
    log('GATT connected');
    await acquireNUS();

    if (isSkeleton) {
      setConnStatus(`Connected: ${device.name}`, 'connected');
      log('Skeleton detected. Safe to OTA — no WDT.');
    } else {
      const ver = await queryDeviceVersion();
      if (ver) {
        setConnStatus(`Connected: ${device.name} — firmware ${ver}`, 'connected');
        log(`Device firmware: ${ver}`);
      } else {
        setConnStatus(`Connected: ${device.name}`, 'connected');
      }
      await prepDevice();
    }

    showMode();
    checkReady();
  } catch (err) {
    log(`Connect error: ${err.message}`);
    setConnStatus(`Error: ${err.message}`, 'error');
  }
}

async function acquireNUS() {
  const service = await server.getPrimaryService(NUS_SERVICE);
  rxChar = await service.getCharacteristic(NUS_RX);
  txChar = await service.getCharacteristic(NUS_TX);
  await txChar.startNotifications();
  txChar.addEventListener('characteristicvaluechanged', onNotify);
  log('NUS ready.');
}

async function queryDeviceVersion() {
  return new Promise((resolve) => {
    let resolved = false;
    const handler = (event) => {
      const text = new TextDecoder().decode(new Uint8Array(event.target.value.buffer));
      try {
        const obj = JSON.parse(text);
        if (obj.fw_version) {
          resolved = true;
          txChar.removeEventListener('characteristicvaluechanged', handler);
          resolve(obj.fw_version);
        }
      } catch (e) {}
    };
    txChar.addEventListener('characteristicvaluechanged', handler);
    rxChar.writeValueWithResponse(new TextEncoder().encode('{"get_info":true}')).catch(() => {});
    setTimeout(() => {
      if (!resolved) {
        txChar.removeEventListener('characteristicvaluechanged', handler);
        resolve(null);
      }
    }, 3000);
  });
}

async function prepDevice() {
  await sendJSON({day_brightness: 0, night_brightness: 0, update_image: true});
  await sendJSON({algo_disable: true});
  log('Device prepped (brightness=0, algo disabled).');
}

async function sendJSON(obj) {
  const data = new TextEncoder().encode(JSON.stringify(obj));
  await rxChar.writeValueWithResponse(data);
  await sleep(300);
}

function onNotify(event) {
  const raw = new Uint8Array(event.target.value.buffer);
  const text = new TextDecoder().decode(raw);
  try {
    if (text.includes('"ota":"ok"')) {
      const m = text.match(/"n":(\d+)/);
      if (m) {
        lastAckedN = parseInt(m[1]);
        ackedCount = lastAckedN + 1;
        updateUI('statAcked', ackedCount);
      }
    } else if (text.includes('"ota":"error"')) {
      log(`Device error: ${text}`);
    } else if (text.includes('"ota":"done"')) {
      log('Device confirmed OTA complete!');
    }
  } catch (e) {}
}

// ============================================================
//  Reconnect helpers
// ============================================================

async function waitForDisconnect(timeoutMs) {
  const start = performance.now();
  while (server && server.connected) {
    if (performance.now() - start > timeoutMs) return false;
    await sleep(200);
  }
  return true;
}

async function autoReconnect(waitS, maxRetries) {
  for (let i = waitS; i > 0; i--) {
    showPhase(`Reboot wait: ${i}s`, 'phase-probe');
    await sleep(1000);
  }
  showPhase('Connecting...', 'phase-count');
  log('Auto-reconnecting...');
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      server = await device.gatt.connect();
      await acquireNUS();
      log(`Reconnected (attempt ${attempt}).`);
      return true;
    } catch (err) {
      log(`Reconnect ${attempt}/${maxRetries}: ${err.message}`);
      await sleep(2000);
    }
  }
  return false;
}

async function readDeviceName() {
  try {
    const gap = await server.getPrimaryService('generic_access');
    const nameChar = await gap.getCharacteristic('gap.device_name');
    const val = await nameChar.readValue();
    return new TextDecoder().decode(val);
  } catch (err) {
    log(`Could not read device name: ${err.message}`);
    return null;
  }
}

// ============================================================
//  Failure recovery
// ============================================================

async function recoverState() {
  hidePhase();
  hideStage();

  if (!server || !server.connected) {
    log('Disconnected. Press Connect to start again.');
    isSkeleton = false;
    rxChar = null;
    setConnStatus('Disconnected', 'disconnected');
    showMode();
    checkReady();
    return;
  }

  log('Detecting current firmware...');
  const name = await readDeviceName();
  if (name) {
    log(`Device name: "${name}"`);
    if (name.toUpperCase().includes('SKEL')) {
      log('Device is on SKELETON. You can retry stage 2.');
      isSkeleton = true;
    } else {
      log('Device is on v4.5.1. You can retry the update.');
      isSkeleton = false;
    }
  } else {
    log('Could not read name. Probing with get_info...');
    let gotResponse = false;
    const handler = (event) => {
      const text = new TextDecoder().decode(new Uint8Array(event.target.value.buffer));
      if (text.length > 5) gotResponse = true;
    };
    txChar.addEventListener('characteristicvaluechanged', handler);
    try {
      await rxChar.writeValueWithResponse(new TextEncoder().encode('{"get_info":true}'));
    } catch (e) {}
    await sleep(2000);
    txChar.removeEventListener('characteristicvaluechanged', handler);

    if (gotResponse) {
      log('Got response — device is on v4.5.1. You can retry the update.');
      isSkeleton = false;
    } else {
      log('No response — device is on SKELETON. You can retry stage 2.');
      isSkeleton = true;
    }
  }

  showMode();
  checkReady();
}

// ============================================================
//  OTA transfer (core engine)
// ============================================================

async function transferOTA(fw, noResponse, paceMs) {
  running = true;
  ackedCount = 0;
  lastAckedN = -1;
  resetProgress();

  document.getElementById('btnStop').style.display = '';
  document.getElementById('btnStop').disabled = false;

  const PAYLOAD_SIZE = 509;
  const totalPackets = Math.ceil(fw.length / PAYLOAD_SIZE);
  const startTime = performance.now();
  let completed = false;

  log(`OTA: ${totalPackets} pkts, ${noResponse ? 'no-resp ' + paceMs + 'ms' : 'with-resp'}, ${(fw.length / 1024).toFixed(1)} KB`);

  for (let i = 0; i < totalPackets; i++) {
    if (!running) { log('Stopped by user.'); break; }
    if (!server || !server.connected) { log('Connection lost!'); break; }

    const start = i * PAYLOAD_SIZE;
    const end = Math.min(start + PAYLOAD_SIZE, fw.length);
    const chunk = fw.slice(start, end);
    const packet = new Uint8Array(3 + chunk.length);
    packet[0] = 0x4F;
    packet[1] = (i >> 8) & 0xFF;
    packet[2] = i & 0xFF;
    packet.set(chunk, 3);

    let writeOk = false;
    if (noResponse) {
      // Retry on buffer full — matches Flutter app: 20ms intervals, 2s timeout
      const deadline = performance.now() + 2000;
      while (true) {
        try {
          await rxChar.writeValueWithoutResponse(packet);
          writeOk = true;
          break;
        } catch (err) {
          if (performance.now() < deadline) {
            await sleep(20);
            continue;
          }
          log(`Write failed pkt ${i}: ${err.message}`);
          break;
        }
      }
      if (writeOk && paceMs > 0) await sleep(paceMs);
    } else {
      try {
        await rxChar.writeValueWithResponse(packet);
        writeOk = true;
      } catch (err) {
        log(`Write failed pkt ${i}: ${err.message}`);
      }
    }
    if (!writeOk) break;

    const sent = i + 1;
    const elapsed = (performance.now() - startTime) / 1000;
    const speed = (sent * PAYLOAD_SIZE / 1024) / elapsed;
    const pct = (sent / totalPackets * 100).toFixed(0);
    const remaining = (totalPackets - sent) / (sent / elapsed);

    document.getElementById('progressFill').style.width = pct + '%';
    document.getElementById('progressText').style.display = '';
    document.getElementById('progressText').textContent = pct + '%';
    updateUI('statSent', sent);
    updateUI('statSpeed', speed.toFixed(1));
    updateUI('statEta', remaining.toFixed(0));

    if (sent % 50 === 0 || sent === totalPackets) {
      log(`${sent}/${totalPackets} (${pct}%) ${speed.toFixed(1)} KB/s`);
    }

    if (sent === totalPackets) completed = true;
  }

  // Finalize
  if (completed && server && server.connected) {
    const fin = new Uint8Array(3);
    fin[0] = 0x4F;
    fin[1] = (totalPackets >> 8) & 0xFF;
    fin[2] = totalPackets & 0xFF;
    try {
      if (noResponse) {
        await rxChar.writeValueWithoutResponse(fin);
      } else {
        await rxChar.writeValueWithResponse(fin);
      }
      log('Finalize sent.');
    } catch (err) {
      log(`Finalize err (may be OK): ${err.message}`);
    }
  }

  const totalTime = ((performance.now() - startTime) / 1000).toFixed(1);
  log(`Transfer: ${totalTime}s. ${completed ? 'OK' : 'INCOMPLETE'}`);

  running = false;
  document.getElementById('btnStop').style.display = 'none';
  return completed;
}

function stopOTA() {
  running = false;
  log('Stopping...');
}

// ============================================================
//  Safe mode: OTA full firmware to skeleton device
// ============================================================

async function safeUpdate() {
  document.getElementById('safeControls').style.display = 'none';
  document.getElementById('stage2Prompt').style.display = 'none';
  showStage(2);
  log('========== Part 2: Full firmware ==========');
  const paceMs = parseInt(document.getElementById('safePaceSlider').value);
  // Skeleton has no WDT — write-with-response is safe and reliable
  const ok = await transferOTA(fullFw, false, paceMs);
  if (ok) {
    showPhase('Update complete', 'phase-go');
    log('Update complete! Device rebooting into ' + FW_FULL_VERSION + '.');
    setTimeout(() => {
      hidePhase(); isSkeleton = false; rxChar = null;
      setConnStatus('Ready for next device', 'disconnected');
      showMode(); checkReady();
    }, 5000);
  } else {
    log('OTA failed.');
    await recoverState();
  }
  hideStage();
}

// ============================================================
//  Full rescue: probe + skeleton + reconnect + full firmware
// ============================================================

async function fullRescue() {
  document.getElementById('rescueControls').style.display = 'none';
  const paceMs = parseInt(document.getElementById('paceSlider').value);

  // ==================== STAGE 1 ====================
  showStage(1);
  log('============================');
  log('  STAGE 1: Skeleton OTA');
  log('============================');

  // --- Probe WDT timing ---
  probing = true;
  showPhase('Probing WDT...', 'phase-probe');
  log('Sending probe packet to measure WDT timing...');

  const probeChunk = skeletonFw.slice(0, Math.min(509, skeletonFw.length));
  const probe = new Uint8Array(3 + probeChunk.length);
  probe[0] = 0x4F;
  probe[1] = 0;
  probe[2] = 0;
  probe.set(probeChunk, 3);

  const probeStart = performance.now();
  try {
    await rxChar.writeValueWithResponse(probe);
  } catch (err) {
    log(`Probe write failed: ${err.message}`);
    probing = false; hidePhase(); hideStage(); showMode(); checkReady();
    return;
  }

  log('Probe sent. Waiting for WDT crash (10-25s)...');

  await new Promise(resolve => {
    const check = setInterval(() => {
      const el = ((performance.now() - probeStart) / 1000).toFixed(1);
      showPhase(`Probing... ${el}s`, 'phase-probe');
      if (!server || !server.connected) { clearInterval(check); resolve(); }
    }, 200);
    setTimeout(() => { clearInterval(check); resolve(); }, 30000);
  });

  const crashTime = performance.now();
  const crashSec = (crashTime - probeStart) / 1000;
  probing = false;

  log(`WDT crash after ${crashSec.toFixed(1)}s.`);

  // --- Reconnect after probe ---
  log('Reconnecting after probe...');
  if (!await autoReconnect(6, 10)) {
    log('Reconnect failed! Refresh page and retry.');
    hidePhase(); hideStage();
    return;
  }

  setConnStatus(`Connected: ${device.name}`, 'connected');
  await prepDevice();

  // --- Calculate optimal timing ---
  const BOOT_DELAY = 3.0;
  const estimatedBootMs = crashTime + BOOT_DELAY * 1000;
  const TARGET_PHASE = 5.5;
  const ALGO_PERIOD = 15;

  const timeSinceBoot = (performance.now() - estimatedBootMs) / 1000;
  const currentPhase = ((timeSinceBoot % ALGO_PERIOD) + ALGO_PERIOD) % ALGO_PERIOD;

  let delay;
  if (currentPhase <= TARGET_PHASE) delay = TARGET_PHASE - currentPhase;
  else delay = ALGO_PERIOD - currentPhase + TARGET_PHASE;
  if (delay < 1.5) delay += ALGO_PERIOD;

  log(`Boot ~${timeSinceBoot.toFixed(1)}s ago. Phase: ${currentPhase.toFixed(1)}s. Waiting ${delay.toFixed(1)}s...`);

  // --- Countdown ---
  const launchAt = performance.now() + delay * 1000;
  while (performance.now() < launchAt) {
    const rem = ((launchAt - performance.now()) / 1000).toFixed(1);
    showPhase(`Stage 1 in ${rem}s`, 'phase-count');
    if (!server || !server.connected) {
      log('Connection lost!'); hidePhase(); hideStage(); showMode(); checkReady(); return;
    }
    await sleep(100);
  }

  // --- Transfer skeleton ---
  showPhase('Stage 1: Skeleton...', 'phase-count');
  log('GO! Transferring skeleton...');

  const ok1 = await transferOTA(skeletonFw, true, paceMs);
  if (!ok1) {
    log('Transfer interrupted. Device is still on original firmware.');
    log('Press Connect to try again.');
    hidePhase();
    hideStage();
    // Device crashed back to v4.5.1 — do NOT run recoverState() which
    // can falsely detect skeleton (device is rebooting, won't answer probes)
    isSkeleton = false;
    rxChar = null;
    setConnStatus('Disconnected', 'disconnected');
    showMode();
    checkReady();
    return;
  }

  // --- Wait for skeleton boot, then prompt user to reconnect ---
  log('Waiting for device to reboot...');
  showPhase('Part 1 complete', 'phase-go');
  await waitForDisconnect(15000);

  hidePhase();
  hideStage();
  log('Part 1 done. Tap Connect to reconnect, then Start Update Part 2.');

  // Show the prompt and switch to skeleton mode so Connect + Part 2 button work
  isSkeleton = true;
  rxChar = null;
  setConnStatus('Disconnected — ready for part 2', 'disconnected');
  document.getElementById('stage2Prompt').style.display = '';
  showMode();
  checkReady();
}

// ============================================================
//  Init
// ============================================================

if (detectPlatform()) {
  loadBundledFirmware();
}
</script>
</body>
</html>
